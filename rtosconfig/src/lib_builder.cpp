#include "lib_builder.h"
#include "parser.h"
#include <fstream>
#include <cassert>

namespace fs = std::filesystem;

/*********************************************/
/* rules where to put library files during building
 * first column - relative path in lib root, second - relative path in build root */

/* rules for all platforms */
LibBuilder::Filemap LibBuilder::common_filemap = {
	// { "common/kernel_module.h",			"impl/include/kernel_module.h" },
	// { "common/kernel_module.cpp",		"impl/src/kernel_module.cpp" }
};

namespace {

/* linux-specific rules */
LibBuilder::Filemap linux_x86_filemap = {
	{ "linux_x86/platform.h",				"impl/include/platform.h" },
	{ "linux_x86/kernel_module.h",			"impl/include/kernel_module.h" },
	{ "linux_x86/kernel_module.cpp",		"impl/src/kernel_module.cpp" }
};

/* linux-specific rules for asm version */
LibBuilder::Filemap linux_x86_asm_filemap = {
	{ "linux_x86_asm/platform.h",			"impl/include/platform.h" },
	{ "linux_x86_asm/asm_macro.h",			"impl/include/asm_macro.h" },
	{ "linux_x86_asm/kernel_module.h",		"impl/include/kernel_module.h" },
	{ "linux_x86_asm/kernel_module.cpp",	"impl/src/kernel_module.cpp" }
};

} // anonymous namespace end

std::map<Target, LibBuilder::Filemap> LibBuilder::target_specific_filemaps = {
	{ Target::eLinux_x86,				linux_x86_filemap },
	{ Target::eLinux_x86_asm,			linux_x86_asm_filemap}
};

/*********************************************/


void LibBuilder::build()
{
	m_config = m_parser->parse();

	try {

	fs::remove_all(m_build_path); // clear if exists
	fs::create_directory(m_build_path);

	std::ofstream rtos_h(m_build_path / "rtos.h");
	std::ofstream rtos_cpp(m_build_path / "rtos.cpp");

	make_rtos_h(rtos_h);
	make_rtos_cpp(rtos_cpp);
	make_impl_files();

	} catch (std::exception& e) {
		fs::remove_all(m_build_path); // clear on failure
		throw;
	}
}


/***********************************************************/


void LibBuilder::make_rtos_h(std::ostream& os)
{
	make_description_section(os, "rtos.h: Mipt-RTOS configuration file");
	os <<
R"(
#include "impl/include/kernel_module.h"

#define decltask(taskname) void detail::__##taskname##_routine(void)

namespace detail {

)";
	for (auto& task : m_config.tasks)
		os << "void __" << task.name << "_routine(void);" << std::endl;
	os <<
R"(
} // detail namespace end

using rt::kernel;

)";
	size_t i = 0;
	for (auto& task : m_config.tasks) {
		os << "inline rt::Task& " << task.name << " = "
			<< "kernel.task(" << i++ << ");" << std::endl;
	}
}


/***********************************************************/


void LibBuilder::make_rtos_cpp(std::ostream& os)
{
	size_t i = 0;

	make_description_section(os, "rtos.cpp: Mipt-RTOS configuration file");
	os <<
R"(
#include "rtos.h"

namespace rt {

Kernel Kernel::m_only_one;

const task_id_t Kernel::m_ntasks = )" << m_config.tasks.size() << ";" << std::endl;

	if (m_config.target == Target::eLinux_x86) {
		os << std::endl << "namespace {" << std::endl << std::endl;

		i = 0;
		for (auto& task : m_config.tasks)
			os << "unsigned char __" << task.name << "_stack[" << task.stack_size << "];" << std::endl;
		os << std::endl << "} // anonymous namespace end" << std::endl;
	}
		os <<
R"(
Task Kernel::m_tasks[Kernel::m_ntasks] = {
)";
	i = 0;
	for (auto& task : m_config.tasks) {
		os << "\tTask(detail::__" << task.name << "_routine, ";
		if (m_config.target == Target::eLinux_x86)
			os << "__" << task.name << "_stack, sizeof __" << task.name << "_stack";
		else if (m_config.target == Target::eLinux_x86_asm)
			os << task.stack_size;
		os << ")" << ((++i != m_config.tasks.size()) ? "," : "") << std::endl;
	}
	os <<
R"(};

task_id_t Kernel::m_current_task = 0;

} // rt namespace end

#include "impl/src/kernel_module.cpp"

)";

}


/***********************************************************/


void LibBuilder::make_description_section(std::ostream& os, const std::string& header)
{
	os <<
R"(/* )" << header << R"(
 * 
 * Copyright (C) 2021 Mipt-RTOS
 *
 * This file is automatically generated by rtosconfig
 * See Mipt-RTOS documentation on https://github.com/graudtV/Mipt-RTOS
 *
 * User project configuration details
 * Platform: )" << to_string(m_config.target) << R"(
 * Tasks:
)";
	for (auto& task : m_config.tasks)
		os << " *\t" << task.name << "\t[stack_size = " << task.stack_size << "]" << std::endl;
	os << " */" << std::endl;
}


/***********************************************************/


void LibBuilder::make_impl_files()
{
	auto impl_path = m_build_path / "impl";

	fs::create_directory(impl_path);
	fs::create_directory(impl_path / "include");
	fs::create_directory(impl_path / "src");

	copy_files(m_lib_path, m_build_path, common_filemap);

	auto filemap = target_specific_filemaps.find(m_config.target);
	if (filemap == target_specific_filemaps.end())
		throw std::runtime_error("unkwown target: " + to_string(m_config.target));
	copy_files(m_lib_path, m_build_path, filemap->second);
}

void LibBuilder::copy_files(const fs::path& src_root, const fs::path& dst_root, const Filemap& filemap)
{
	for (auto& mapping : filemap)
		fs::copy_file(src_root / mapping.first, dst_root / mapping.second);
}